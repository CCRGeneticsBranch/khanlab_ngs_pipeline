HLA ={}
if 'subject' in config:
	for subject in config['subject']:
		for library in config['subject'][subject]:
			if config['sample_captures'][library] not in config['Panel_List']:
				TARGET    += [subject+"/"+TIME+"/"+library+"/HLA/seq2HLA/"+library+"-ClassI.HLAgenotype4digits"]
				TARGET    += [subject+"/"+TIME+"/"+library+"/HLA/HLAminer/HLAminer_HPTASR.csv"]
				TARGET    += [subject+"/"+TIME+"/"+library+"/HLA/"+library+".Calls.txt"]
if 'sample_references' in config:
	if len(config['sample_references']) > 0:
		for Tumor in config['sample_references']:
			for Normal in config['sample_references'][Tumor]:
				seq2HLA    = "{subject}/{TIME}/{sample}/HLA/seq2HLA/{sample}-ClassI.HLAgenotype4digits".format(TIME=TIME, subject=SAMPLE_TO_SUBJECT[Normal], sample=Normal)
				HLAminer   = "{subject}/{TIME}/{sample}/HLA/HLAminer/HLAminer_HPTASR.csv".format(TIME=TIME, subject=SAMPLE_TO_SUBJECT[Normal], sample=Normal)
				if config['sample_captures'][Tumor] not in config['Panel_List']:
					# any output which is desired on all somatic libraries but Panel goes here, the list of panel captures should be maintained in the Panel_List in config file
					HLA[Tumor] = [seq2HLA, HLAminer]
	for sample in config['sample_references'].keys():
		subject=SAMPLE_TO_SUBJECT[sample]
		if config['sample_captures'][sample] not in config['Panel_List']:
			#TARGET    +=[subject+"/"+TIME+"/"+sample+"/NeoAntigen/MHC_Class_I/"+sample+".final.tsv"]
			TARGET    +=[subject+"/"+TIME+"/"+sample+"/NeoAntigen/"+sample+".final.txt"]

if 'RNASeq' in config:
	for subject  in config['RNASeq'].keys():
		for sample in SAM_RNASEQ[subject]:
			TARGET    +=  [subject+"/"+TIME+"/"+sample+"/HLA/seq2HLA/"+sample+"-ClassI.HLAgenotype4digits"]
			TARGET    +=  [subject+"/"+TIME+"/"+sample+"/HLA/HLAminer/HLAminer_HPTASR.csv"]
			TARGET    +=  [subject+"/"+TIME+"/"+sample+"/HLA/"+sample+".Calls.txt"]

############
#	seq2HLA
############
rule seq2HLA:
	input:  R=lambda wildcards: FQ[wildcards.sample],
	output:
		"{base}/{TIME}/{sample}/HLA/seq2HLA/{sample}-ClassI.HLAgenotype4digits"
	params:
		rulename= "seq2HLA",
		python  = config["version_python"],
		R	= config['version_R'],
		bowtie	= config['bowtie'],
		batch	= config[config['host']]["job_hla"],
		HLA	= config['HLA'],
		script = config['app_home'] + "/seq2HLA/seq2HLA.py"
	shell: """
	#######################
	module load bowtie/{params.bowtie} python/{params.python} R/{params.R}
	python {params.script} {params.HLA}/seq2HLA/ -1 {input.R[0]} -2 {input.R[1]}  -p ${{THREADS}} -r {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/HLA/seq2HLA/{wildcards.sample}
	#######################
	"""
############
#	HLAminer
############
rule HLAminer:
	input:	R=lambda wildcards: FQ[wildcards.sample],
	output: "{base}/{TIME}/{sample}/HLA/HLAminer/HLAminer_HPTASR.csv"
	params:
		rulename="HLAminer",
		batch	=config[config['host']]["job_hlaminer"],
		HLA	=config['HLA'],
        workdir=WORK_DIR,
		location=NGS_PIPELINE,
		script_home = config['app_home'] + "/HLAminer_v1.3.1/bin/"
	shell: """
	#######################
	#echo {params.workdir}/{input.R[0]} >{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/HLA/HLAminer/patient.fof
	#echo {params.workdir}/{input.R[1]} >>{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/HLA/HLAminer/patient.fof

	echo {input.R[0]} >{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/HLA/HLAminer/patient.fof
	echo {input.R[1]} >>{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/HLA/HLAminer/patient.fof
	
	sh {params.script_home}HPTASRwgs_classI.sh {params.script_home} {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/HLA/HLAminer/
	#######################
	"""
############
##       MergeHLA Calls
#############
rule MergeHLA:
	input:
		A="{base}/{TIME}/{sample}/HLA/HLAminer/HLAminer_HPTASR.csv",
		B="{base}/{TIME}/{sample}/HLA/seq2HLA/{sample}-ClassI.HLAgenotype4digits",
	output:
		"{base}/{TIME}/{sample}/HLA/{sample}.Calls.txt"
	params:
		rulename = "MergeHLA",
		Tool=NGS_PIPELINE + "/scripts/consensusHLA.pl",
		batch    = config[config['host']]["job_default"]
	shell: """
	#######################
	export LC_ALL=C
	perl {params.Tool} {input.B} {input.A} | sort > {output}	
	#######################
	"""
############
#	VEP4pVACSeq
############
rule VEP:
	input:
		"{base}/{TIME}/{sample}/calls/{sample}.strelka.indels.raw.vcf",
		"{base}/{TIME}/{sample}/calls/{sample}.strelka.snvs.raw.vcf",
		"{base}/{TIME}/{sample}/calls/{sample}.MuTect.raw.vcf",
		HLA  =lambda wildcards: HLA[wildcards.sample],
		tool =NGS_PIPELINE + "/scripts/consensusSomaticVCF.pl",
	output: 
		vcf	="{base}/{TIME}/{sample}/NeoAntigen/{sample}.final.vcf",
	params:
		rulename = "VEP",
		VEP	 = config['VEP'],
		merge=NGS_PIPELINE + "/scripts/consensusHLA.pl",
		normal	 = lambda wildcards: config['sample_references'][wildcards.sample][0],
		batch    = config[config['host']]["job_VEP"],
	shell: """
	#######################
	module load vcftools VEP/{params.VEP} perl
	perl {input.tool} -vcf {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/calls/{wildcards.sample}.strelka.indels.raw.vcf,{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/calls/{wildcards.sample}.strelka.snvs.raw.vcf,{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/calls/{wildcards.sample}.MuTect.raw.vcf -order {params.normal},{wildcards.sample} -filter REJECT |vcf-subset -u -c {wildcards.sample} >{output.vcf}.tmp
	variant_effect_predictor.pl -i {output.vcf}.tmp --plugin Downstream --plugin Wildtype --terms SO --offline --cache --dir_cache $VEPCACHEDIR --assembly GRCh37 --output_file {output.vcf} --vcf --force_overwrite
	rm -rf {output.vcf}.tmp
	export LC_ALL=C
	perl {params.merge} {input.HLA[0]} {input.HLA[1]} | sort > {wildcards.base}/{wildcards.TIME}/{params.normal}/HLA/{params.normal}.Calls.txt
	#######################
	"""
#splits = [chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX,chrY]
splits = ['chr1:1-120000001','chr1:120000001-249250621','chr2:1-120000001','chr2:120000001-243199373','chr3:1-120000001','chr3:120000001-198022430','chr4:1-120000001','chr4:120000001-191154276','chr5:1-120000001','chr5:120000001-180915260','chr6','chr7','chr8','chr9','chr10','chr11','chr12','chr13','chr14','chr15','chr16','chr17','chr18','chr19','chr20','chr21','chr22','chrX','chrY']

###########
#       split_vcf
###########
rule split_vcf:
	input:
		lambda wildcards: "{base}/{TIME}/" +config['sample_references'][wildcards.sample][0]+"/HLA/" +config['sample_references'][wildcards.sample][0]+".Calls.txt",
		vcf = "{base}/{TIME}/{sample}/NeoAntigen/{sample}.final.vcf",
#		lambda wildcards: "{base}/{TIME}/" +config['sample_references'][wildcards.sample][0]+"/HLA/" +config['sample_references'][wildcards.sample][0]+".Calls.txt",
#		{base}/{TIME}/{sample}/HLA/{sample}.Calls.txt
	output:
#		out = "{base}/{TIME}/{sample}/NeoAntigen/split/split_complete",
		out = expand("{{base}}/{{TIME}}/{{sample}}/NeoAntigen/split/{{sample}}_sorted_{split}.vcf",split = splits)
	params:
		rulename = "split_vcf",
		VEP	 = config['VEP'],
		batch    = config[config['host']]["job_VEP"],
	shell: """
	########################
	module load vcftools bcftools
	mkdir -p {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split
	vcf-sort {input.vcf} > {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf
	bgzip -c {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf > {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf.gz
	tabix -p vcf {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf.gz
#	grep -vE "^#" {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf |cut -f1 |uniq| while read i ; do tabix -h {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf.gz $i  > {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_sorted_$i.vcf ; done
	for i in {splits} ; do tabix -h {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final_sorted.vcf.gz $i  > {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_sorted_$i.vcf ; done
	chgrp khanlab {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/*
	#########################
	"""
############
#       pVACSeq
#############
rule pVACseq:
	input:
		vcf = "{base}/{TIME}/{sample}/NeoAntigen/split/{sample}_sorted_{split}.vcf",
	output:
		"{base}/{TIME}/{sample}/NeoAntigen/split/{sample}_{split}/MHC_Class_I/{sample}_{split}.filtered.tsv",
#		"{base}/{TIME}/{sample}/NeoAntigen/{sample}.final.txt"
	version: config['pvacseq']
	params:
		rulename = "pVACseq",
		python   = config["version_python"],
		normal   = lambda wildcards: config['sample_references'][wildcards.sample][0],
#		vcfin =  lambda wildcards: config[splits][0],		
		tool 	 = NGS_PIPELINE + "/scripts/pvacseq.sh",
		IEDB	 = config['IEDB'],
		version	= config['pvacseq'],
		batch    = config[config['host']]["job_pvacseq"],
		host	 = config['host']
	shell: """
	#######################
#	allele=`cut -f1 {wildcards.base}/{wildcards.TIME}/{params.normal}/HLA/{params.normal}.Calls.txt |grep -v Allele|tr '\\n' ',' |sed -e 's/,$//g'`
	
	module load pvactools/{version} 
	mkdir -p {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split}
	{params.tool} {wildcards.base}/{wildcards.TIME}/{params.normal}/HLA/{params.normal}.Calls.txt {input.vcf} {wildcards.sample}_{wildcards.split} {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split} {params.version}
#	cd {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split}
#	pvacseq run --iedb-install-directory /opt/iedb -e 8,9,10,11,12,13,14 -t ${{THREADS}} --fasta-size=400 {input.vcf} {wildcards.sample}_{wildcards.split} ${{allele}} {{NNalign,NetMHC,NetMHCIIpan,NetMHCcons,NetMHCpan,PickPocket,SMM,SMMPMBEC,SMMalign}} {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split} 2>{wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split}/{wildcards.sample}_{wildcards.split}_err
#	is_empty=$(grep "TSV file is empty" {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split}/{wildcards.sample}_{wildcards.split}_err|wc -l)
#	wait
#	export LC_ALL=C
	if [ -f {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/split/{wildcards.sample}_{wildcards.split}/MHC_Class_I/{wildcards.sample}_{wildcards.split}.filtered.tsv ]
	then
		echo "pVACSeq step is complete"
	else
		touch {output}
	fi
	#######################
	"""


#############
#	Merge_pvacseq
#############
rule Merge_pvacseq:
	input:
		expand("{{base}}/{{TIME}}/{{sample}}/NeoAntigen/split/{{sample}}_{split}/MHC_Class_I/{{sample}}_{split}.filtered.tsv",split = splits)
	output:
		"{base}/{TIME}/{sample}/NeoAntigen/{sample}.final.txt"
	version: config['pvacseq']
	params:
		rulename = "Merge_pvacseq",
		python   = config["version_python"],
		tool     = NGS_PIPELINE + "/scripts/process_pVACSeq.pl",
		batch    = config[config['host']]["job_pvacseq"],
		host	= config['host']
	shell: """
	##################
	awk 'FNR>1 || NR==1' {input} > {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.filtered.tsv
	awk 'NR == 1; NR > 1 {{print $0 | "sort -n"}}' {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.filtered.tsv |uniq > {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final.uniq.tsv
	perl {params.tool} {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final.uniq.tsv |awk 'NR == 1; NR > 1 {{print $0 | "sort -n"}}'|uniq > {output}
	chgrp khanlab {wildcards.base}/{wildcards.TIME}/{wildcards.sample}/NeoAntigen/{wildcards.sample}.final.txt
	##################
	"""
